import "hashes/pedersen/512bit" as hash
import "hashes/sha256/sha256"
import "hashes/utils/256bitsDirectionHelper" as multiplex

const u32 DEPTH = 8

/* Modified from Zokrates official example: https://github.com/Zokrates/ZoKrates/blob/deploy/zokrates_cli/examples/merkleTree/pedersenPathProof3.zok
 *
 * Merke-Tree inclusion proof for tree depth 4 using SNARK-efficient pedersen hashes
 * directionSelector => true if current digest is on the rhs of the hash
 */
def leafExists(u32[8] root, u32[8] leaf, bool[DEPTH] directionSelector, u32[DEPTH][8] path) -> bool:
    // Start from the leaf
    u32[8] digest = leaf

    // Loop up the tree
    for u32 i in 0..DEPTH do
        u32[16] preimage = multiplex(directionSelector[i], digest, path[i])
        digest = hash(preimage)
    endfor

    return (digest == root)

// // Checks a modification of a merkle tree by 1 leaf for correctness
// def updateMerkleRoot(u32[8] oldRoot, u32[8] newRoot, u32[8] oldLeaf, u32[8] newLeaf, bool[DEPTH] directionSelector, u32[DEPTH][8] path) -> bool:
//     assert(leafExists(oldRoot, oldLeaf, directionSelector, path))
    
//     // Start from the leaf
//     u32[8] digest = newLeaf
//     // Loop up the tree
//     for u32 i in 0..DEPTH do
//         u32[16] preimage = multiplex(directionSelector[i], digest, path[i])
//         digest = hash(preimage)
//     endfor

//     return (digest == newRoot)

// create a leaf by hashing: 20-byte address followed by 28-byte creds, followed by 16-byte nullifier
def recreateLeaf(u32[5] address, u32[7] creds, u32[4] nullifier) -> u32[8]:
    u32[16] preimage = [...address, ...creds, ...nullifier]
    return hash(preimage)

// NOTE : careful to use a hash which is secure under this construction (e.g., no attacks similar to length-extension)
def trapdoorCommit(u32[8] value, u32[8] trapdoor) -> u32[8]:
    u32[16] preimage = [...value, ...trapdoor]
    return hash(preimage)

// Unecessary for now -- later can be used to transfer root from authority (creator) to user
// // Verifies that a trapdoor change is valid, so a user can change the commitment on their value, essentially re-encrypting the same value
// def prepareTrapdoorChange(u32[8] oldCommitment, u32[8] newCommitment, private u32[8] value, private u32[8] oldTrapdoor, private u32[8] newTrapdoor) -> u32[8]: //, private u32[8] newTrapdoorHash
//    assert(trapdoorCommit(u32[8] value, u32[8] oldTrapdoor) == oldCommitment)
//    assert(trapdoorCommit(u32[8] value, u32[8] newTrapdoor) == newCommitment)
// //    assert(sha256(newTrapdoor) == newTrapdoorHash) 
   

def main(u32[8] rootCommitment, private u32[8] root, private u32[8] trapdoor, private bool[DEPTH] directionSelector, private u32[DEPTH][8] path, private u32[5] issuerAddress, private u32[7] creds, private u32[4] nullifier):
    // Recreat leaf from private parameters
    u32[8] leaf = recreateLeaf(issuerAddress, creds, nullifier)
    // Assert root is correct
    assert(trapdoorCommit(root, trapdoor) == rootCommitment)
    // Assert leaf is in tree with root root
    assert(leafExists(root, leaf, directionSelector, path))
    return
