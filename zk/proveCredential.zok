import "hashes/mimcSponge/mimcSponge" as hash;
import "hashes/blake2/blake2s" as leafHash;
// import "hashes/sha256/sha256" as leafHash;
import "hashes/utils/256bitsDirectionHelper" as multiplex;

const u32 DEPTH = 8;
const u32 NUMLEAVES = 256; //2^DEPTH

/* Modified from Zokrates official example: https://github.com/Zokrates/ZoKrates/blob/deploy/zokrates_cli/examples/merkleTree/pedersenPathProof3.zok
 *
 * Merke-Tree inclusion proof
 * directionSelector => true if current digest is on the rhs of the preimage, false if current digest is on the lhs of the preimage
 */
// def leafExists(u32[8] root, u32[8] leaf, bool[DEPTH] directionSelector, u32[DEPTH][8] path) -> bool {
//     // Start from the leaf
//     u32[8] mut digest = leaf;

//     // Loop up the tree
//     for u32 i in 0..DEPTH {
//         u32[16] preimage = multiplex(directionSelector[i], digest, path[i]);
//         digest = hash(preimage);
//     }
        
//     return (digest == root);
// }
def leafExists(field[1] root, field leaf, bool[DEPTH] directionSelector, field[DEPTH] path) -> bool {
    // Start from the leaf
    field[1] mut digest = [leaf];

    // Loop up the tree
    for u32 i in 0..DEPTH {
        field[2] inputs = directionSelector[i] ? [path[i], digest[0]] : [digest[0], path[i]];
        digest = hash(inputs, 0);
    }
        
    return (digest == root);
}
    

// // Checks a modification of a merkle tree by 1 leaf for correctness
// def updateMerkleRoot(u32[8] oldRoot, u32[8] newRoot, u32[8] oldLeaf, u32[8] newLeaf, bool[DEPTH] directionSelector, u32[DEPTH][8] path) -> bool:
//     assert(leafExists(oldRoot, oldLeaf, directionSelector, path))
    
//     // Start from the leaf
//     u32[8] digest = newLeaf
//     // Loop up the tree
//     for u32 i in 0..DEPTH do
//         u32[16] preimage = multiplex(directionSelector[i], digest, path[i])
//         digest = hash(preimage)
//     endfor

//     return (digest == newRoot)

// create a leaf by hashing: 20-byte address followed by 28-byte creds, followed by 16-byte nullifier
def leafFromData(u32[5] address, u32[7] creds, u32[4] nullifier) -> u32[8] {
    u32[1][16] preimage = [[...address, ...creds, ...nullifier]];
    return leafHash(preimage);
}
    

// NOTE : careful to use a hash which is secure under this construction (e.g., no attacks similar to length-extension)
// def trapdoorCommit(u32[8] value, u32[8] trapdoor) -> u32[8] {
//     u32[16] preimage = [...value, ...trapdoor];
//     return hash(preimage);
// }

// NOTE : careful to use a hash which is secure under this construction (e.g., no attacks similar to length-extension)
// def trapdoorCommit(u32[8] value, u32[8] trapdoor) -> u32[8] {
//     u32[16] preimage = [...value, ...trapdoor];
//     return hash(preimage);
// }

// Unecessary for now -- later can be used to transfer root from authority (creator) to user
// // Verifies that a trapdoor change is valid, so a user can change the commitment on their value, essentially re-encrypting the same value
// def prepareTrapdoorChange(u32[8] oldCommitment, u32[8] newCommitment, private u32[8] value, private u32[8] oldTrapdoor, private u32[8] newTrapdoor) -> u32[8]: //, private u32[8] newTrapdoorHash
//    assert(trapdoorCommit(u32[8] value, u32[8] oldTrapdoor) == oldCommitment)
//    assert(trapdoorCommit(u32[8] value, u32[8] newTrapdoor) == newCommitment)
// //    assert(sha256(newTrapdoor) == newTrapdoorHash) 

def main(field root, private bool[DEPTH] directionSelector, private u32[DEPTH][8] path, private u32[5] issuerAddress, private u32[7] creds, private u32[4] nullifier, u8[20] myAddress) {
    // Recreat leaf from private parameters
    u32[8] leaf = leafFromData(issuerAddress, creds, nullifier);
    // Assert root is correct
    assert(trapdoorCommit(root, trapdoor) == rootCommitment);
    // Assert leaf is in tree with root root
    assert(leafExists(root, leaf, directionSelector, path));
    return;
}

// def main(u32[8] rootCommitment, private u32[8] root, private u32[8] trapdoor, private bool[DEPTH] directionSelector, private u32[DEPTH][8] path, private u32[5] issuerAddress, private u32[7] creds, private u32[4] nullifier, u8[20] myAddress) {
//     // Recreat leaf from private parameters
//     u32[8] leaf = leafFromData(issuerAddress, creds, nullifier);
//     // Assert root is correct
//     assert(trapdoorCommit(root, trapdoor) == rootCommitment);
//     // Assert leaf is in tree with root root
//     assert(leafExists(root, leaf, directionSelector, path));
//     return;
// }
    



// // Generate root hash (this will be used to create the merkle root client-side -- not part of the actual proof! should be a different file)
// def createMerkleTree(u32[256][8] leaves) -> u32[8]:
//     u32[1][8] result = [[0; 8]]
//     // u32[2][8]
//     // u32[4][8]
//     // u32[8][8]
//     // u32[16][8]
//     // u32[32][8]
//     // u32[64][8]
//     // u32[128][8]

//     for i in 0..NUMLEAVES:
//         result[0] = hash(leaves[i])
