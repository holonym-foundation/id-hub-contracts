import "hashes/pedersen/512bit" as hash
import "hashes/utils/256bitsDirectionHelper" as multiplex
// from "./strings.zok" import substringAt

const u32 DEPTH = 3;

// Modified from Zokrates official example: https://github.com/Zokrates/ZoKrates/blob/deploy/zokrates_cli/examples/merkleTree/pedersenPathProof3.zok
// Merke-Tree inclusion proof for tree depth 4 using SNARK-efficient pedersen hashes
// directionSelector => true if current digest is on the rhs of the hash
def leafExists(u32[8] root, u32[8] leaf, bool[DEPTH] directionSelector, u32[DEPTH][8] path):
    // Start from the leaf
    u32[8] mut digest = leaf;

    // Loop up the tree
    for u32 i in 0..DEPTH do
        u32[16] preimage = multiplex(directionSelector[i], digest, path[i]);
        digest = hash(preimage);
    endfor

    assert(digest == root);

// checks validity of leaf, that it's comprised of a certain 20-byte address folowed by certain 44-byte creds
// def assertValidLeaf(u32[8] leaf, u32[5] address, u32[11] creds):
//     u32[16] preimage = [...address, ...creds]
//     assert(hash(preimage) == digest)
//     return

// create a leaf by hashing: 20-byte address followed by  44-byte creds
def recreateLeaf(u32[5] address, u32[11] creds) -> u32[8]:
    u32[16] preimage = [...address, ...creds]
    return hash(preimage)

def credentialExists(u32[8] merkleRoot, private bool[DEPTH] directionSelector, private u32[DEPTH][8] path, u32[5] issuerAddress, u32[11] creds):
    u32[8] leaf = recreateLeaf(address, creds)
    leafExists(merkleRoot, leaf, directionSelector, path)
    