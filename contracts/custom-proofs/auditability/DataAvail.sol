// SPDX-License-Identifier: MIT

/* This is the data availabilty part of zkEscrow. It stores encrypted user data, given by the zk-escrow npm package.
 * It allows for statements of the form "I have stored properly-encrypted data to this contract, and the commitment to my data is X"
 * Then, users can do arbitrary proofs of the data by opening the commitment in a zksnark.
 * Neither the ciphertext and the commitment stored here can be broken by quantum computers, nor lost in a data breach of a single master key.
 */
pragma solidity ^0.8.9;

struct Point {
    uint x;
    uint y;
}

struct ElGamalCiphertext {
    Point c1;
    Point c2;
}

// A tag is given in the proof of correct encryption, as the public signals. It is all the information that will be needed to recover the plaintext.
// Notably, it has a Pedersen commitment to the plaintext data. That way, once data is stored in this contract, a user can open the commitment in another
// zksnark to prove facts about it.
struct Tag {
    // points to a contract that will have to the has access interface
    // function hasAccess(byte32 tagId, address auditor): reutrns (boolean)
    address accessControlLogic;
    // Pedersen commitment (Quantum Resistant Commitment)
    Point commitment;
    ElGamalCiphertext ciphertext;
    uint prfIn;
}

struct PublicSignal {
    uint x;
    uint y;
}

// groth16 verifier generaged by circom
interface IVerifier {
    function verify(
        uint[] calldata proof,
        uint[] calldata publicSignals
    ) external view returns (bool success);
}

contract DataAvail {
    event TagAdded(bytes32 tagId, Tag tag);
    IVerifier verifier;
    mapping(bytes32 => Tag) tagForAvailID;

    constructor(address _verifier) {
        verifier = IVerifier(_verifier);
    }

    function getTagId(Tag memory tag) public pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked(
                    tag.accessControlLogic,
                    tag.commitment.x,
                    tag.commitment.y
                )
            );
    }

    /**
     * Stores tags in the contract, given a (zk) proof of correct encryption.
     * the contract will have a verifyer contract that will verify the proof.
     * data that's generated by the npm package (zk-escrow)
     */
    function storeData(
        uint[] calldata proof,
        uint[] calldata publicSignals
    ) public returns (bool) {
        require(
            verifier.verify(proof, publicSignals),
            "failed to verify proof of correct encryption"
        );
        // tbd: check that the proof is for the correct access control logic
        // get the file that clarifes this from circom.
        Tag memory tag = Tag(
            publicSignals[0],
            Point(publicSignals[1], publicSignals[2]),
            ElGamalCiphertext(
                Point(publicSignals[3], publicSignals[4]),
                Point(publicSignals[5], publicSignals[6])
            ),
            publicSignals[7]
        );
        bytes32 tagId = getTagId(tag);

        require(tagForAvailID[tagId], "Please use a new tagId / commitment");

        tagForAvailID[tagId] = tag;
        emit TagAdded(tagId, tag);
        return true;
    }

    // Gets the availID for a tag, which helps check whether the tag has been stored:
    function getAvailID(Tag memory tag) public pure returns (bytes32 id) {
        return getTagId(tag);
    }

    // Checks a tag has been stored:
    function checkDataAvailability(
        Point memory dataCommitment,
        address accessControlLogic
    ) public view returns (bool available) {
        bytes32 id = getAvailID(dataCommitment, accessControlLogic);
        // This line works because if tagForAvailID[id] is uninitialized, the accessControlLogic will be the zero address
        return
            (tagForAvailID[id].accessControlLogic == accessControlLogic) &&
            (accessControlLogic != address(0));
    }
}
